#!/usr/bin/env perl
use 5.14.0;
use warnings;
no warnings 'exiting';
use utf8::all;
use Anki::Corpus;
use Term::ReadKey;

die "usage: $0 query\n" unless @ARGV;

ReadMode 3;
END { ReadMode 0 }

my $corpus = Anki::Corpus->new;

sub copy {
    my $text = shift;
    open my $handle, '| pbcopy';
    print $handle $text;
    close $handle;
    say "Copied: $text";
}

my %commands = (
    "s" => {
        description => 'suspend sentence',
        code        => sub { shift->suspend }
    },
    "u" => {
        description => 'unsuspend sentence',
        code        => sub { shift->unsuspend },
    },
    "d" => {
        description => 'delete sentence',
        code        => sub { shift->delete },
    },
    "q" => {
        description => 'cut out all this nonsense',
        code        => sub { ReadMode 0; exit },
    },
    "N" => {
        description => 'copy sentence (日本語)',
        code        => sub { copy(shift->japanese) },
    },
    "S" => {
        description => 'copy source (出所)',
        code        => sub { copy(shift->source) },
    },
    "H" => {
        description => 'copy translation (翻訳)',
        code        => sub { copy(shift->translation) },
    },
    "Y" => {
        description => 'copy readings (読み)',
        code        => sub { copy(shift->readings) },
    },
);
my $commands = join '', sort keys %commands;

my $cb = sub {
    my %args     = @_;
    my $sentence = $args{sentence};
    my $regex    = $args{regex};
    my $index    = $args{index};
    my $count    = $args{count};

    while (1) {
        print "\n";
        $corpus->print_sentence($sentence, $regex);

        local $commands{j} = {
            description => 'down one',
            code        => sub {
                last;
            },
        } if ${ $args{next} } < $count;

        my $back_one = $index - 1;
        local $commands{k} = {
            description => 'up one',
            code        => sub {
                ${ $args{next} } = $back_one;
                last;
            },
        } if $back_one >= 0;

        delete local $commands{H} unless $sentence->has_translation;
        delete local $commands{Y} unless $sentence->has_readings;
        delete local $commands{$sentence->suspended ? 's' : 'u'};

        $commands{'?'} = {
            description => 'get help',
            code        => sub {
                for my $key (sort keys %commands) {
                    say "$key: $commands{$key}{description}";
                }
            },
        };

        my $commands = join '', sort keys %commands;
        local $| = 1;
        print "[".($index+1)."/$count] Command [$commands]: ";

        my $command = ReadKey 0;
        do { ReadMode 0; exit } if !defined($command);
        print "$command\n";
        last if $command eq "\n" || $command eq " ";

        if (!exists($commands{$command})) {
            say "Invalid command $command";
            next;
        }

        $commands{$command}{code}->($sentence);
        $sentence->refresh;
    }
};

my $count = $corpus->scan_for([@ARGV], $cb, 'WHERE suspended=1');

if (!$count) {
    say "No suspended results, showing unsuspended rows";
    $corpus->scan_for([@ARGV], $cb, 'WHERE suspended=0');
}

